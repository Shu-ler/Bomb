/*
	Программа управления шутейной трехзагадочной бомбой
	Для Arduino Mega 2560
	
	Филимонов И.В.
	+79236501926
	shu-ler@live.ru
	Версия 9, 14 октября 2018г
*/
#include <TM1637.h>		// Библиотека индикатора на TM1637 https://github.com/AlexGyver/GyverLibs/archive/master.zip
#include <iarduino_KB.h>	// Библиотека клавиатуры http://iarduino.ru/lib/a732af8a49763aa509845f98ba70a031.zip
#include <SPI.h>
#include <SD.h>

#define	  NL	'\n'

template <typename T> inline Print & operator << (Print &s, T n) {
	s.print(n);
	return s;
}

//================== Флаги условной компиляции - нужное раскомментировать ===================================================
//#define DEBUG					// Отладка
//#define DEBUG1    				// Отладка первого задания (ввод кода)
//#define DEBUG2    				// Отладка второго  задания (подсоединения проводов)
//#define DEBUG3    				// Отладка третьего задания (повторение стрелок)
//#define DEBUGSD				// Отладка чтения с карты microSD

//================== Порты подключения четырехразрядных индикаторов =========================================================
#define CLK0  16				// CLK индикатора MainClock					
#define DIO0  17				// DIO индикатора MainClock
#define CLK1  20				// CLK индикатора Task3Clock
#define DIO1  21				// DIO индикатора Task3Clock
#define CLK2  18				// CLK индикатора CodeWindow
#define DIO2  19				// DIO индикатора CodeWindow

//================== Порты подключения LEDов ================================================================================
#define T3LED1	8				//						H5
#define T3LED2	9				//	Порты стрелочных LEDов второго задания	H6
#define T3LED3	10				//						B4
#define T3LED4	11				//						B5

#define T1R		4			// Порт красного LEDа первого задания		G5
#define T1G		5			// Порт зеленого LEDа первого задания		E3
#define T2R		3			// Порт красного LEDа второго задания		E5
#define T2G		2			// Порт зеленого LEDа второго задания		E4
#define T3R		6			// Порт красного LEDа третьего задания		H3
#define T3G		7			// Порт зеленого LEDа третьего задания		H4

//================== Порты остальных компонентов ============================================================================
#define ZUMM		14			// Порт пьезопищалки
#define SD_CARD		53			// Порт устройства чтения microSD
#define RELE		46			// Порт реле
#define KEYS_PIN	A0			// Порт стрелочных кнопок третьего задания
#define KBD  22, 23, 24, 25, 47, 48, 49 	// Порты цифровой клавиатуры

#define T2IN		26			//
#define T2OUT		36			//

//================== Значения основных констант =============================================================================
#define DEFAULT_CODE0		'3'		// Первый символ пароля по умолчанию
#define DEFAULT_CODE1		'5'		// Второй символ пароля по умолчанию
#define DEFAULT_CODE2		'0'		// Третий символ пароля по умолчанию
#define DEFAULT_CODE3		'8'		// Четвертый символ пароля по умолчанию
#define LEDS_COUNT 		10		// Количество светодиодов
#define CLOCK_LEVEL		3		// Уровень яркости четырехразрядных индикаторов, 0 - 7 (минимум - максимум)
#define DURATION_ALL		900		// Продолжительность квеста по умолчанию, с
#define DURATION_TASK3		180		// Продолжительность третьей задачи по умолчанию, с
#define INTERVAL1_TASK3		2000  		// Продолжительность свечения стрелок на 1-м этапе третьего задания по умолчанию, мс
#define INTERVAL2_TASK3		1000  		// Продолжительность свечения стрелок на 2-м этапе третьего задания по умолчанию, мс
#define INTERVAL3_TASK3		500   		// Продолжительность свечения стрелок на 3-м этапе третьего задания по умолчанию, мс
#define ARR_DELAY		75		// Задержка нажатия стрелок (гашение дребезга), мс
#define MAX_DIG_CODE		4		// Количество цифр в пароле
#define RUN_STRING		50		// Продолжительность свечения "бежащей цифры", мс
#define RUN_LED			300		// Продолжительность свечения "бегущего LEDа", мс
#define KEY_SOUND_DUR		200		// Продолжительность звука при нажатии цифры, мс
#define KEY_TONE		300		// Базовый тон звука при нажатии цифры
#define D_VOLTA			10		// Отклонение напряжения от номинала на аналоговых пинах
#define NUM_KEYS		4		// Количество стрелок на третьем этапе
#define TASK2COUNT		5		// Количество необходимых удачных циклов второго задания

#define ON      1
#define OFF     0

//================== Имена файлов ===========================================================================================
#define FILE_INI 	"bomba.txt"		// Имя файла основных параметров
#define FILE_PASS 	"pass.txt"		// Имя файла пароля
#define FILE_START 	"start.txt"		// Имя файла стартовой мелодии
#define FILE_END_SUC 	"suc.txt"		// Имя файла финишной мелодии - успех
#define FILE_END_FAIL 	"fail.txt"		// Имя файла финишной мелодии - неудача
#define FILE_OK 	"ok.txt"		// Имя файла мелодии "Ок"
#define FILE_NO 	"no.txt"		// Имя файла мелодии "No"

//================== Длины мелодий (для звуковых массивов) ==================================================================
#define SSTART_L	10				// Длина стартовой мелодии
#define SESUC_L		78				// Длина финишной мелодии - успех
#define SEFAIL_L	5				// Длина финишной мелодии - неудача
#define SOK_L		5				// Длина мелодии "Ок"
#define SNO_L		5				// Длина мелодии "No"
#define SOUND_MAX_L	85				// Максимальная длина мелодии

//================== Переменные длины мелодий для звуковых массивов =========================================================
const	uint8_t	sStartL	= SSTART_L;		// Длина стартовой мелодии
const	uint8_t	sESucL	= SESUC_L;		// Длина финишной мелодии - успех
const	uint8_t	sEFailL	= SEFAIL_L;		// Длина финишной мелодии - неудача
const	uint8_t	sOkL	= SOK_L;		// Ддина мелодии "Ok"
const	uint8_t	sNoL	= SNO_L;		// Ддина мелодии "No"

//================== Звуковые массивы =======================================================================================
// Первый столбец - частота звука, второй - длительность в мс
int sStart[SSTART_L][2] =				// Набор стартовых звуков
		{
		{392, 200},	{392, 200},	{392, 200},
		{392, 200},	{900, 200},	{900, 200},
		{900, 200},	{900, 200},	{900, 200},
		{1500, 1000}
		};
int sESuc[SESUC_L][2] = 				// Финишная мелодия - успех
		{
		{1175, 78},	{1245, 78},	{1175, 78},	{1175, 78},	{1245, 78},	{1175, 78},
		{1245, 78},	{1175, 78},	{1245, 78},	{1175, 78},	{1245, 78},	{1175, 78},	
		{1175, 78},	{1245, 78},	{1319, 78},	{1397, 78},	{1480, 78},	{1568, 78},
		{1568, 157},	{0, 315},	{1568, 157},	{0, 315},	{1865, 157},	{0, 157},
		{2093, 157},	{0, 157},	{1568, 157},	{0, 315},	{1568, 157},	{0, 315},
		{1397, 157},	{0, 157},	{1480, 157},	{0, 157},	{1568, 157},	{0, 315},
		{1568, 157},	{0, 315},	{1865, 157},	{0, 157},	{2093, 157},	{0, 157},
		{1568, 157},	{0, 315},	{1568, 157},	{0, 315},	{1397, 157},	{0, 157},
		{1480, 157},	{0, 157},	{1865, 157},	{1568, 157},	{1175, 1262},	{0, 78},
		{1865, 157},	{1568, 157},	{1109, 1262},	{0, 78},	{1865, 157},	{1568, 157},
		{1047, 1262},	{932, 157},	{1047, 315},	{0, 1262},	{0, 78},	{932, 157},
		{784, 157},	{1480, 1262},	{0, 78},	{932, 157},	{784, 157},	{1397, 1262},
		{0, 78},	{932, 157},	{784, 157},	{1319, 1262},	{1245, 157},	{1175, 315}
		};
int sEFail[SEFAIL_L][2] =				// Финишная мелодия - неудача
		{
		{1000, 1000}, 	{1000, 1000},	{1000, 1000},	{1000, 1000},	{1000, 6000}
		};
int sOk[SOK_L][2] =					// Мелодия "Ok"
		{
		{784, 600},	{0, 100},	{659, 150},	{0, 100},	{523, 150}
		};
int sNo[SNO_L][2] =					// Мелодия "No"
		{
		{523, 200},	{0, 100},	{523, 200},	{0, 100},	{523, 400}
		};

//================== Переменные для таймеров ================================================================================
unsigned long tHalfSec;				// Переменная для входа в полусекундную обработку
unsigned long tTime0;				// Время запуска квеста (миллисекунды)
unsigned long tTimeN;				// Время окончания квеста (миллисекунды)
unsigned long tTimeCL;				// Время окончания третьей задачи
unsigned long tStage2, tStage3;			// Время перехода на 2-й и 3-й этапы третьей задачи
unsigned long tQuestDuration = DURATION_ALL;	// Длительность всего квеста в секундах
unsigned long tSecTask3 = DURATION_TASK3;	// Длительность третьей задачи в секундах

unsigned long timeS0, timeSn;

//================== Флаги ==================================================================================================
boolean bTask1Prog = true;			// Первая задача в процессе выполнения
boolean bTask2Prog = true;			// Вторая задача в процессе выполнения
boolean bTask3Prog = false;			// Третья задача в процессе выполнения

boolean bTask1Suc = false;			// Первая задача успешно выполнена
boolean bTask2Suc = false;			// Вторая задача успешно выполнена
boolean bTask3Suc = false;			// Третья задача успешно выполнена

boolean bTask1Led = false;			// Светится ли LED первого задания
boolean bTask2Led = true;			// Светится ли LED второго задания
boolean bTask3Led = true;			// Светится ли LED третьего задания

boolean bDots;					// Включить точки на часах. Он же признак прошедшей секунды
boolean bLEDfl[] = {false, false, false, false};// Флаги стрелочных LEDов
boolean bHalt = false;				// Остановка loop()

boolean sound = false;
boolean soundSuccess = false;

int LEDs[] = {T3R, T3G, T1R, T1G, T2R, T2G, T3LED1, T3LED2, T3LED3, T3LED4};	// Массив портов LEDов для функции Show()
int LED3Array[] = {T3LED1, T3LED2, T3LED3, T3LED4};	// Порты стрелочных  LEDов

const int dUAnalog = D_VOLTA;				// Максимальное отклонение напряжения от ожидаемого на аналоговых портах
int ClockLevel = CLOCK_LEVEL;				// Уровень яркости четырехразрядных индикаторов

//================== Переменные для первого задания =========================================================================
char Code[MAX_DIG_CODE] = {DEFAULT_CODE0, DEFAULT_CODE1, DEFAULT_CODE2, DEFAULT_CODE3};	// Массив эталонного пароля
byte CodeBuf[MAX_DIG_CODE];				// Массив символов для вывода на индикатор при наборе пароля
char KeyArray[MAX_DIG_CODE];				// Массив вводимого пароля

//================== Переменные для второго задания =========================================================================
const byte ALines = 10; 				// Количество проводов
boolean bCord[ALines];					// Флаги правильного подключения проводов

//================== Переменные для третьего задания ========================================================================
int SCount = 0;					// Количество правильных ответов третьего этапа
unsigned long tTimeArr;				// Время начала нового считывания кнопок стрелок
unsigned long ArrDelay = ARR_DELAY;		// Задержка нажатия кнопки стрелки
unsigned long tArrInter = INTERVAL1_TASK3;	// Длительность свечения LED стрелки на 1-й стадии
unsigned long tArrInter2 = INTERVAL2_TASK3;	// Длительность свечения LED стрелки на 2-й стадии
unsigned long tArrInter3 = INTERVAL3_TASK3;	// Длительность свечения LED стрелки на 3-й стадии
unsigned long tArrEnd;				// Время окончания свечения LED стрелки

//================== Объявление объектов ====================================================================================
TM1637 MainClock(CLK0, DIO0);			// Четырехразрядный индикатор основных часов 
TM1637 Task3Clock(CLK1, DIO1);			// Четырехразрядный индикатор третьего задания
TM1637 CodeWindow(CLK2, DIO2);			// Четырехразрядный индикатор ввода кода
iarduino_KB KB(KBD);				// Цифровая клавиатура
File currentFile;				// Указатель на файл

//================== Прототипы функций ======================================================================================
boolean ReadSarray(int SArr[SOUND_MAX_L][2], int Rows, String FName);
void FinalSuc();
void FinalFail();


//===========================================================================================================================
// Setup - функция, выполняемая однократно при запуске ПЛК
//===========================================================================================================================
void setup() {
int i;

#ifdef DEBUG							//---------- начало условной компиляции - отладка ----------
	Serial.begin(115200);					//	Инициализация терминала 
	Serial << "Отладка программы БОМБА" << NL << "Филимонов И.В." << NL;	//	Сообщение на терминал
#endif								//---------- окончание условной компиляции - отладка -------

	for  (i = 0; i < LEDS_COUNT; i++)		// 
		pinMode(LEDs[i], OUTPUT);		// Установка режима портов для LEDов
	for (i = 0; i < ALines; i++)			//
		{					//
		pinMode(T2IN + i, INPUT);		// Установка режима портов для входов второго задания
		digitalWrite(T2IN + i, HIGH);		//
		pinMode(T2OUT + i, OUTPUT);		// Установка режима портов для выходов второго задания
		digitalWrite(T2OUT + i, HIGH);		// Установка в единицу выходов второго задания
		}
	pinMode(ZUMM, OUTPUT);				// Установка режима порта для пьезопищалки
	pinMode(RELE, OUTPUT);				// Установка режима порта для реле
	digitalWrite(RELE, LOW);			// Переключение реле (замыкание цепи питания от Кроны)
	
	randomSeed(analogRead(A1));			// Инициализация генератора псевдослучайных цифр
	
	ReadConfig();					// Считывание параметров из файлов, инициализация переменных					

	MainClock.init();				// Инициализация 4-разрядного индикатора основных часов
	Task3Clock.init();				// Инициализация 4-разрядного индикатора третьего задания
	CodeWindow.init();				// Инициализация 4-разрядного индикатора первого задания

	MainClock.set(ClockLevel);			// Установка уровня яркости 4-разрядного индикатора
	Task3Clock.set(ClockLevel);			// Установка уровня яркости 4-разрядного индикатора
	CodeWindow.set(ClockLevel);			// Установка уровня яркости 4-разрядного индикатора

	KB.begin(KB3);          			// Инициализация цифровой клавиатуры
	Show();						// Бегущие огоньки и шум при запуске устройства
	CWinit();					// Вывод "_ _ _ _" на индикатор первого задания
	
	tTime0 = millis();				// Установка времени начала квеста
	tTimeN = tTime0 + tQuestDuration * 1000;	// Установка времени окончания квеста

#ifdef DEBUG							//---------- начало условной компиляции - отладка ----------
	Serial << "Setup - установка времени начала квеста - " << tTime0 << NL;
	Serial << "Setup - установка времени окончания квеста - " << tTimeN << NL;
	Serial << "Setup - длительность квеста - " << tQuestDuration << NL;
	Serial << "Setup - длительность третьего задания - " << tSecTask3 << NL;
	Serial << "Setup - интервал в третьем задании - " << tArrInter << NL;
	Serial << "Setup - завершение функции" << NL;
#endif								//---------- окончание условной компиляции - отладка -------
}

//===========================================================================================================================
// Loop
//===========================================================================================================================
void loop() {
unsigned long tCurrent;						// Текущее время с момента запуска МК

	if (bHalt) return;					// Запрет работы loop()
	
	tCurrent = millis();					// Считываем текущий тик
	if (tCurrent > tTimeN)  				// Если время квеста истекло:
		{						//
		FinalFail();					//	- обработка неудачного завершения квеста
		}						//
  
	//---------------------- Действие каждые полсекунды ------------------------------------------------------------------
	if (tCurrent - tHalfSec > 500)				// Если прошло полсекунды
		{
		tHalfSec =  tCurrent;            		// 	- сбросить таймер
		bDots = !bDots;                  		//	- переключить флаг  точек
		LEDsTimes();					// 	- перерисовать LEDы и четырехразрядные индикаторы
		if (bTask2Prog)					// Если вторая задача в процессе выполнения:
			Task2();				//	- запустить обработчик второй задачи
		}

	//---------------------- Действие каждый цикл ------------------------------------------------------------------------
	if (bTask1Prog)						// Если первая задача в процессе выполнения:
		Task1();					//	- запустить обработчик первой задачи

	if (bTask3Prog)						// Если третья задача в процессе выполнения:
		Task3();					//	- запустить обработчик третьей задачи
  
	if (!bTask3Prog && !bTask3Suc) 				// Если третья задача не в процессе выполнения и не была выполнена:
		if (ReadArrow() > 0) 				//	- считать кнопку со стрелкой. Если нажата хоть одна из стрелок:
			{					//
			bTask3Prog = true;			//		- установить флаг процесса выполнения
			tTimeCL = tCurrent + tSecTask3 * 1000;	//		- установить время окончания задачи
			tStage2 = tCurrent + tSecTask3 * 333;	//		- установить время перехода на второй этап задачи
			tStage3 = tCurrent + tSecTask3 * 666;	//		- установить время перехода на третий этап задачи
			tArrEnd = tCurrent + tArrInter;		//		- установить время свечения первого индикатора
#ifdef DEBUG								//-------- Начало условной компиляции - отладка -----
			Serial << "Loop - старт третьей задачи" << NL;
			Serial << "Loop - время окончания третьей задачи - " << tTimeCL << NL;
			Serial << "Loop - время перехода на вторую стадию - " << tStage2 << NL;
			Serial << "Loop - время перехода на третью стадию - " << tStage3 << NL;
#endif									//-------- Окончание условной компиляции - отладка --
			}

	if (bTask1Suc && bTask2Suc && bTask3Suc)		// Если все задачи успешно завершены
		FinalSuc();					//	- вызов функции обработки успешного завершения квеста
}

//===========================================================================================================================
// Первое задание - ввод кода
//===========================================================================================================================
void Task1() {
  const byte CodeTab[] = {_0, _1, _2, _3, _4, _5, _6, _7, 0xff, _9};  // Таблица символов для индикатора
  char Key;				// Буфер ввода символа
  byte NumKey = 0;		// Буфер ввода цифры
  int i;				// Бегунок для циклов

	if (KB.check(KEY_DOWN ))				// Если нажимается   кнопка номеронабирателя:
		{						//
		Key = KB.getChar;				//    - считывается символ
		NumKey = KB.getNum;				//    - считывается номер клавиши
#ifdef DEBUG1								//---------- начало условной компиляции - отладка ----------
		Serial << "Task1 - Нажата клавиша №" << NumKey << NL;	//  Значение на терминал
#endif									//---------- конец условной компиляции - отладка ----------
		if (Key == '#')					// Если нажата решетка:
			{					//
			SoundFail();				//
			CWinit();				//  - вызов функции сброса набора
			}					//
		else if (Key == '*')				// Если нажата звездочка:
			CodeCheck();				//  - вызов функции проверки введенного кода
		else						// Если нажата цифра:
			{					//
			for (i = 0; i < MAX_DIG_CODE - 1; i++)	//  - сдвигаем в массиве на вывод и в массиве на проверку кода
				{				//	ранее введенные символы на одну позицию влево.
				CodeBuf[i] = CodeBuf[i + 1];	//    	Символ из первого поля теряется
				KeyArray[i] = KeyArray[i + 1];  //
				}				//
			CodeBuf[MAX_DIG_CODE - 1] = CodeTab[NumKey];	//  - заносим в массив на вывод код для отображения (из массива CodeTab)
			KeyArray[MAX_DIG_CODE - 1] = Key;		//  - заносим в массив пароля символ на проверку пароля
#ifdef DEBUG1									//---------- начало условной компиляции - отладка ----------
			Serial << "Task1 -  Код для вывода: ";			//  Сообщение на терминал
			for (i = 0; i < MAX_DIG_CODE; i++)			//  В цикле -
				{						//
				Serial << CodeBuf[i] << ", ";			//    вывод значения на терминал через запятую
				}						//
			Serial << NL;						//  Сообщение на терминал
#endif										//---------- конец условной компиляции - отладка ----------
			SoundPlay((int)(NumKey + 1) * KEY_TONE, KEY_SOUND_DUR);	// Проигрыш звука нажатой цифровой клавиши
			CodeWindow.clearDisplay();				// Очистка индикатора
			CodeWindow.displayByte(CodeBuf);			// Вывод текущего введенного кода на индикатор
			}
		}
}

//===========================================================================================================================
// Второе задание - подсоединение проводов
//===========================================================================================================================
void Task2() {
int 	i, j;										// Бегунок для циклов
static int T2Count = 0;

#ifdef DEBUG2										//---------- начало условной компиляции - отладка ---
	Serial << "Проверка подключения проводков по второму тесту..." << NL;
#endif

	//bTask2Suc = true;								// Установить флаг успешного выполнения второго задания в 1
	T2Count = 0;
	for (i = 0; i < ALines; i++) 						// 
		{									// Для каждого провода;
		digitalWrite(T2OUT+i, LOW);
		if (digitalRead(T2IN + i) == LOW)
			{
			T2Count++;
			}
#ifdef DEBUG2										//---------- начало условной компиляции - отладка ---
		Serial << "i = " << i << NL;
		for (j=0; j < ALines; j++)
			{
			Serial << digitalRead(T2IN + j);
			}
		Serial << NL;
		for (j=0; j < ALines; j++)
			{
			Serial << digitalRead(T2OUT + j);
			}
		Serial << NL << "============" << NL;
		//delay(500);
#endif											//---------- конец условной компиляции - отладка ----
		digitalWrite(T2OUT+i, HIGH);					// 
		}									//
#ifdef DEBUG2										//---------- начало условной компиляции - отладка ---
	Serial << "Правильных проводов - " << T2Count << NL;
#endif											//---------- конец условной компиляции - отладка ----

	if (T2Count == ALines) 							// Если задание выполнено:
		{									//
		for (j=0; j < ALines; j++)					//	- в цикле:
			{								//
			digitalWrite(T2OUT + j, LOW);				//		- сброс выходов в ноль
			}								//
		bTask2Prog = false;						// 	- сброс флага прогресса задания
		bTask2Suc = true;							//	- установка флага завершения задания
		SoundSuc();								//	- воспроизведение победной мелодии
		}
}

//===========================================================================================================================
// Третье задание - повтор стрелок
//===========================================================================================================================
void Task3() {
static int CurrentLED = 0;								// Текущий активный LED
static int PrevLED = 5;									// Предыдущий активный LED
int 	Arr = 0;										// Нажатая кнопка
static boolean bLED1 = false;								// Флаг наличия горящего LEDа
unsigned long tCur;									// Время входа в процедуру
int i, j;											// Бегунки для циклов

	tCur = millis();									// Получение текущего времени

  	//====== Время изменения этапов =============================================
	if (tCur > tStage2)							// перехода на вторую или третью стадии этапа (tStage2 и tStage3 соответственно
		{
#ifdef DEBUG3
		Serial << "Task3 - интервал изменился с " << tArrInter << " на " << tArrInter2 << NL;
#endif
		tArrInter = tArrInter2;							//
		tStage2=tStage2+tTimeN;
		}

  	if (tCur > tStage3)								//
    		{
#ifdef DEBUG3
		Serial << "Task3 - интервал изменился с " << tArrInter << " на " << tArrInter3 << NL;
#endif
    		tArrInter = tArrInter3;							// Изменение длительности свечения стрелочного LEDа (tArrInter) в случае 
    		tStage3=tStage3+tTimeN;							//	наступления времени
    		}
		
  	//====== Время задания вышло ================================================
	if (tCur > tTimeCL) 								// Если текущее время превышает точку остановки задачи:
		{
		bTask3Suc = true;								// 	- установка флага успешного завершения
		bTask3Prog = false;							// 	- сброс флага выполнения задания
		digitalWrite(T3R, !bTask3Suc);					//	- выключение красного LEDа
		digitalWrite(T3G, bTask3Suc);						//	- включение зеленого LEDа
		SoundSuc();									// 	- проигрыш победной мелодии
		Task3Clock.set(0);							// 	- приглушение уровня яркости 4-разрядного индикатора
		for (i = 0; i < 4; i++)							//	- в цикле для всех стрелочных LED:
			digitalWrite(LED3Array[i], LOW);   				// 		- гашение стрелочных LEDов
#ifdef DEBUG3
		Serial << "Task3 - завершилось время выполнения задания, итог - " << SCount << NL;
#endif
		}
	
	//====== Время свечения LEDа вышло =============================================
	if (tCur > tArrEnd ) 						// Гашение LED по таймеру (tArrEnd - время окончания)
		{
		for(j=0; j<4; j++)
			{
			bLEDfl[CurrentLED] = false;			// Сброс флага LED
			digitalWrite(LED3Array[CurrentLED], LOW);		// Гашение LED
			}
		CurrentLED = random(0, 4);					//	- выбор LED по генератору
		while (CurrentLED  == PrevLED)				//
			{
			CurrentLED = random(0, 4);				//
			}
		PrevLED = CurrentLED;						//	- запоминание LED для исключения повторов
		bLEDfl[CurrentLED] = true;					//	- установка флага включенного LED
		digitalWrite(LED3Array[CurrentLED], HIGH);		//	- включение LED
		tArrEnd = tCur + tArrInter;					//	- установка времении выключения LED
#ifdef DEBUG3				
		Serial << "Task3 - вышло время свечения LED. Запускается LED " << CurrentLED;
		Serial << " PrevLED=" << PrevLED << " t0=" << tCur << " tn=" << tArrEnd << NL;
		for (j=0; j<4; j++)
			{
			Serial << "\tbLEDfl[" << j << "]=" << bLEDfl[j];
			}
		Serial << NL;
#endif
		Task3Clock.clearDisplay();		//	- очистка индикатора
		Task3Clock.displayInt(SCount);	//	- вывод количества правильных ответов
		}
		
	//====== Время задания не вышло =============================================
	if (tCur < tTimeCL)
		{
		Arr = ReadArrow();
		if (Arr > 0) 
			{
			tTimeArr=tCur+ArrDelay;
#ifdef DEBUG
			Serial << "Task3 - клавиша - " << Arr << " LED - " << CurrentLED;
			Serial << " Прав. ответов - " << SCount << NL;
#endif
			bLEDfl[CurrentLED] = false;			// Сброс флага LED
			digitalWrite(LED3Array[CurrentLED], LOW);	// Гашение LED
			tArrEnd = tCur;					//
			if (Arr == (CurrentLED+1)) 			// Проверка соответствия нажатой кнопки включенному LEDу. При успехе:
				{						//
				CurrentLED=NUM_KEYS;			//
				SCount++;					//	- увеличение счетчика правильных ответов
				Task3Clock.clearDisplay();		//	- очистка индикатора
				Task3Clock.displayInt(SCount);	//	- вывод количества правильных ответов
				}
			}
		}
}

//==========================================================================================================================
// ReadArrow() - обработка нажатия стрелочной клавиши
//==========================================================================================================================
int ReadArrow() {
const int 	abc_key_val[NUM_KEYS] = {20, 520, 680, 780};
const int 	retVal[] = {1, 2, 4, 3};
int 	input = 0;
int	k = 0;

	if (tTimeArr>millis())
		return 0;

	input = analogRead(KEYS_PIN);
	for (k = 0; k < NUM_KEYS; k++)
		if (abs(input - abc_key_val[k]) < dUAnalog) 
			{
			return retVal[k];
			}
	return 0;
}

//==========================================================================================================================
// LEDsTimes() Отрисовка полей - мигание/горение LEDов, мигание 3-х часов
//==========================================================================================================================
void LEDsTimes() {
byte DIGITS[4];
int sec,  mins;
int i;

	digitalWrite(T1R, !bTask1Suc & bTask1Led);		// Вкл/выкл красный LED в центре
	digitalWrite(T1G, bTask1Suc);					// Вкл/выкл зеленый LED в центре
	bTask1Led = !bTask1Led;						// Перебросить флаг LED в центре

	digitalWrite(T2R, !bTask2Suc & bTask2Led);		// Вкл/выкл красный LED слева
	digitalWrite(T2G, bTask2Suc);					// Вкл/выкл зеленый LED слева
	bTask2Led = !bTask2Led;						// Перебросить флаг LED слева

	digitalWrite(T3R, !bTask3Suc & bTask3Led);		// Вкл/выкл красный LED справа
	digitalWrite(T3G, bTask3Suc);					// Вкл/выкл зеленый LED справа
	bTask3Led = !bTask3Led;						// Перебросить флаг LED справа

	MainClock.point(bDots);						// Включить или выключить точки на  основных часах
	Task3Clock.point(bDots && !bTask3Prog && !bTask3Suc);	// Включить или выключить точки на часах третьей задачи

	sec =  (tTimeN - millis()) / 1000;     			// Получить секунды до окончания квеста
	mins = floor(sec / 60);        				// Получить целые минуты из секунд
	sec = sec - (mins * 60);       				// Найти оставшиеся целые секунды
	DIGITS[0] = mins / 10;           				// Получить десятки минут
	DIGITS[1] = mins % 10;          				// Получить единицы минут
	DIGITS[2] = sec / 10;            				// Получить десятки секунд
	DIGITS[3] = sec % 10;            				// Получить единицы секунд
	MainClock.display(DIGITS);          			// Вывести массив на дисплей

	//=============== Управляем секундомером над стрелками
	if (!bTask3Prog) 							// Третья задача не  активна
		{								//
		if (bTask3Suc) 						// Если выполнена:
			{      						//
			if (bTask3Led)					//
				Task3Clock.clearDisplay();		//	- гасим индикатор
			else							//		или
				Task3Clock.displayInt(SCount);	//	- отражаем количество правильных ответов
			}							//
		else if (bTask3Led) 					// Пассивная третья задача - выводим время задачи на индикатор:
			{      						//
			sec = tSecTask3;       				// 	- длительность выполнения третьей задачи в секундах
			mins = floor(sec / 60);        		// 	- получить целые минуты из секунд
			sec = sec - (mins * 60);       		// 	- найти оставшиеся целые секунды
			DIGITS[0] = mins / 10;           		// 	- получить десятки минут
			DIGITS[1] = mins % 10;           		// 	- получить единицы минут
			DIGITS[2] = sec / 10;            		// 	- получить десятки секунд
			DIGITS[3] = sec % 10;            		// 	- получить единицы секунд
			Task3Clock.display(DIGITS);          	// 	- вывести массив на дисплей
			}							//
		else								//
			Task3Clock.clearDisplay();			// или погасить индикатор
		}
}

//==========================================================================================================================
// Стартовое шоу - мигание LEDов, бегущие цифры
//==========================================================================================================================
void Show() {
int i, j;
#ifdef DEBUG
	Serial << "Show - запуск функции" << NL;
#endif

  for  (i = 0; i < LEDS_COUNT; i++) {
    digitalWrite(LEDs[i], HIGH);
    delay(RUN_LED);
    digitalWrite(LEDs[i], LOW);
  }

  for (i = 0; i < 10; i++) {
    tone(ZUMM, sStart[i][0], sStart[i][0]);
    for (j = 0; j < 4; j++) {
      MainClock.display(j, i);
      delay(RUN_STRING);
      MainClock.clearDisplay();
    }
    for (j = 0; j < 4; j++) {
      CodeWindow.display(j, i);
      delay(RUN_STRING);
      CodeWindow.clearDisplay();
    }
    noTone(ZUMM);
    for (j = 0; j < 4; j++) {
      Task3Clock.display(j, i);
      delay(RUN_STRING);
      Task3Clock.clearDisplay();
    }
  }
 	delay(500);
 	noTone(ZUMM);
#ifdef DEBUG
	Serial << "Show - завершение функции" << NL;
#endif
}

//===========================================================================================================================
// Инициализация индикатора ввода кода (отображение "_ _ _ _")
//===========================================================================================================================
void CWinit() {
uint8_t i;

	for (i = 0; i < MAX_DIG_CODE; i++)		// \ Заполнить буфер символами "_"
		CodeBuf[i] = _under;			// /
	CodeWindow.clearDisplay();			// Очистить индикатор
	CodeWindow.displayByte(CodeBuf);		// Вывести буфер на индикатор
}

//===========================================================================================================================
// Проверка введенного кода
//===========================================================================================================================
void CodeCheck() {
uint8_t	i;
#ifdef DEBUG1
	Serial << "CodeCheck - Код при проверке: ";
	for (i = 0; i < MAX_DIG_CODE; i++)
	{
		Serial << CodeBuf[i] << ", ";
	}
	Serial << " ...Ok" << NL;
#endif

	bTask1Suc = true;
	for (i = 0; i < MAX_DIG_CODE; i++) 
		{
		bTask1Suc = bTask1Suc & (KeyArray[i] == Code[i]);
		}
	if (bTask1Suc) 
		{
		bTask1Prog = false;
		SoundSuc();
		CodeWindow.set(0);
		}
	else 
		{
		SoundFail();
		CWinit();
		}
}

//===========================================================================================================================
// Воспроизведение звука
//===========================================================================================================================
void SoundPlay(int freq, int dur) {
	timeS0 = millis();
	timeSn = timeS0 + dur;
	sound = true;
	tone(ZUMM, freq, dur);
	delay(dur);
}

//===========================================================================================================================
// SoundSuc() - Воспроизведение мелодии выполнения задания
//===========================================================================================================================
void SoundSuc() {
byte 	i;

	for (i = 0; i < sOkL; i++)
		SoundPlay(sOk[i][0], sOk[i][1]);
}

//===========================================================================================================================
// SoundFail() - Воспроизведение мелодии неправильного ответа
//===========================================================================================================================
void SoundFail() {
byte 	i;

	for (i = 0; i < sNoL; i++)
		SoundPlay(sNo[i][0], sNo[i][1]);
}

//===========================================================================================================================
// Загрузка конфигурации из файла
//===========================================================================================================================
void ReadConfig() {
String buf;									// Буфер для пароля
byte i = 0, j = 0;							// Бегунки для циклов

#ifdef DEBUGSD									//---------- начало условной компиляции - отладка --------
	Serial << "ReadConfig - инициализация карты...";		//	Сообщение на терминал
#endif										//---------- конец условной компиляции - отладка ---------
	if (!SD.begin(SD_CARD)) { 					// \
										//
		while (1);							//  Инициализация устройства считывания microSD.
		}								// /
#ifdef DEBUGSD									//---------- начало условной компиляции - отладка --------
	Serial << "...Ok" << NL;						//	Сообщение на терминал
#endif										//---------- конец условной компиляции - отладка ---------

	// ===================== Обработка файла конфигурации ========================================
#ifdef DEBUGSD									//---------- начало условной компиляции - отладка --------
	Serial << "  ReadConfig - чтение файла BOMBA.txt...";		//          Сообщение на терминал
#endif										//---------- конец условной компиляции - отладка ---------

	currentFile = SD.open(FILE_INI);				// Открытие файла конфигурации BOMBA.txt
	if (currentFile) 							// При успехе -
		{
#ifdef DEBUGSD									//---------- начало условной компиляции - отладка --------
		Serial << "...Ok" << NL;					//          Сообщение на терминал
#endif										//---------- конец условной компиляции - отладка ---------
		tQuestDuration = Read1();				//	- переназначаем tQuestDuration
		tSecTask3 = Read1();					//	- переназначаем tSecTask3
		tArrInter = Read1();					//	- переназначаем tArrInter
		tArrInter2 = Read1();					//	- переназначаем tArrInter2
		tArrInter3 = Read1();					//	- переназначаем tArrInter3
		ClockLevel = Read1();					//	- переназначаем ClockLevel
		currentFile.close();					// и закрываем файл
#ifdef DEBUGSD										//---------- начало условной компиляции - отладка ----------
		Serial << "  ReadConfig - установка tQuestDuration = " << tQuestDuration << NL;	//
		Serial << "  ReadConfig - установка tSecTask3 = " << tSecTask3 << NL;			//
		Serial << "  ReadConfig - установка tArrInter = " << tArrInter << NL;			//
		Serial << "  ReadConfig - установка tArrInter2 = " << tArrInter2 << NL;			//
		Serial << "  ReadConfig - установка tArrInter3 = " << tArrInter3 << NL;			//
		Serial << "  ReadConfig - установка ClockLevel = " << ClockLevel << NL;			//
#endif											//---------- конец условной компиляции - отладка ----------
		}
	else									// При неудачном открытии файла не делаем ничего. 
		{								// Все переменные из файла ранее получили значения по умолчанию.
#ifdef DEBUGSD									//---------- начало условной компиляции - отладка ----------
		Serial << "...Fail" << NL;					//          Сообщение на терминал
#endif										//---------- конец условной компиляции - отладка ----------
		}                                                                                                                                                   

  // ===================== Обработка файла пароля ========================================
#ifdef DEBUGSD										//---------- начало условной компиляции - отладка ----------
	Serial << "  ReadConfig - чтение файла PASS.txt...";			//	Сообщение на терминал
#endif											//---------- конец условной компиляции - отладка ----------

	currentFile = SD.open(FILE_PASS);						// Открытие файла пароля PASS.txt
	if (currentFile)									// При успехе -
		{
#ifdef DEBUGSD											//---------- начало условной компиляции - отладка ----------
		Serial << "...Ok" << NL;							//	Сообщение на терминал
#endif												//---------- конец условной компиляции - отладка ----------
		buf = currentFile.readStringUntil('\n');				//	- считывание строки в buf
		while (!isdigit(buf[i]))						//	- поиск первой цифры в buf
			i++;									//
		for (j = 0; j < 4; j++)							//	- копирование четырех цифр из buf в Code
			Code[j] = buf[i++];						//
		currentFile.close();							// и закрытие файла
#ifdef DEBUGSD											//---------- начало условной компиляции - отладка ----------
		Serial << "  ReadConfig - установка Buf = " << buf << NL;		//
		Serial << "  ReadConfig - установка Code = " << Code << NL;		//
#endif												//---------- конец условной компиляции - отладка ----------
		}

  // ===================== Обработка звуковых файлов ========================================
#ifdef DEBUGSD											//---------- начало условной компиляции - отладка ----------
	Serial << "  ReadConfig - чтение файла " << FILE_START;			//	Имя файла на терминал
#endif												//---------- конец условной компиляции - отладка ----------
	ReadSarray(sStart, sStartL, FILE_START);					//
#ifdef DEBUGSD											//---------- начало условной компиляции - отладка ----------
	for (i = 0; i < sStartL; i++) 							//	Цикл перебора строк массива для вывода на терминал
		{
		Serial << "  ReadConfig - " << sStart[i][0] << ", " << sStart[i][1] << NL;	//	Значение на терминал
		}
#endif												//---------- конец условной компиляции - отладка ----------

#ifdef DEBUGSD											//---------- начало условной компиляции - отладка ----------
	Serial << "  ReadConfig - чтение файла " << FILE_END_SUC << NL;		//	Имя файла на терминал
#endif												//---------- конец условной компиляции - отладка ----------
	ReadSarray(sESuc, sESucL, FILE_END_SUC);

#ifdef DEBUGSD											//---------- начало условной компиляции - отладка ----------
	Serial << "  ReadConfig - чтение файла " << FILE_END_FAIL << NL;		//	Имя файла на терминал
#endif												//---------- конец условной компиляции - отладка ----------
	ReadSarray(sEFail, sEFailL, FILE_END_FAIL);

#ifdef DEBUGSD											//---------- начало условной компиляции - отладка ----------
	Serial << "  ReadConfig - чтение файла " << FILE_OK << NL;			//	Имя файла на терминал
#endif												//---------- конец условной компиляции - отладка ----------
	ReadSarray(sOk, sOkL, FILE_OK );

#ifdef DEBUGSD											//---------- начало условной компиляции - отладка ----------
	Serial << "  ReadConfig - чтение файла " << FILE_NO << NL;			//	Имя файла на терминал
#endif												//---------- конец условной компиляции - отладка ----------
	ReadSarray(sNo, sNoL, FILE_NO);

#ifdef DEBUGSD											//---------- начало условной компиляции - отладка ----------
  Serial << "ReadConfig - завершение функции" << NL;					//	Сообщение на терминал
#endif												//---------- конец условной компиляции - отладка ----------
}

//===========================================================================================================================
// Считывание одного целого числа, отличного от нуля, из открытого файла, с текущей позиции
//===========================================================================================================================
int Read1() {
int AAA;

	AAA = currentFile.parseInt();			// Получение из файла целого числа (если с текущей позиции можно получить 
								//	целое, либо нуля (строки с текстом и т.п.)
	while (AAA < 1) {					// Повтор до тех пор, пока не считается положительное число
		AAA = currentFile.parseInt();		//
		};

#ifdef DEBUGSD							//---------- начало условной компиляции - отладка ----------
	Serial << "      Read1 - " << AAA << NL;		//	полученного значения
#endif								//---------- конец условной компиляции - отладка ----------
	return AAA;						// Возврат значения
}

//===========================================================================================================================
// Считывание массива звуков
//===========================================================================================================================
boolean ReadSarray(int SArr[SOUND_MAX_L][2], int Rows, String FName) {
int	i, j;

#ifdef DEBUGSD									//---------- начало условной компиляции - отладка ----------
	Serial << "      ReadSarray - чтение файла " << FName << NL;	//	Значение на терминал
#endif										//---------- конец условной компиляции - отладка ----------

	currentFile = SD.open(FName);					// Открытие файла FName
	if (currentFile) 							// При успехе -
		{
#ifdef DEBUGSD									//---------- начало условной компиляции - отладка ----------
		Serial << "...Ok" << NL;					//	Сообщение на терминал
#endif										//---------- конец условной компиляции - отладка ----------
		for (i = 0; i < Rows; i++) 
			{
			for (j = 0; j < 2; j++) 
				{
				SArr[i][j] = currentFile.parseInt();
      			}
#ifdef DEBUGSD									//---------- начало условной компиляции - отладка ----------
			Serial << "      ReadSarray - " << SArr[i][0] << ", " << SArr[i][1] << NL;	//	Значение на терминал
#endif										//---------- конец условной компиляции - отладка ----------
			}
		currentFile.close();					// и закрытие файла
#ifdef DEBUGSD									//---------- начало условной компиляции - отладка ----------
		Serial << "      ReadSarray - завершение " << NL;	//	Сообщение на терминал
#endif										//---------- конец условной компиляции - отладка ----------
		}
	return true;
}

//*********************************************************************
// Финал игры - успех
//*********************************************************************
void FinalSuc() {
int i;

#ifdef DEBUG
	Serial << "FinalSuc - начало функции" << NL;
#endif
	delay(2000);
	for (i=0; i<sESucL; i++)
		{
		SoundPlay(sESuc[i][0], sESuc[i][1]);
		}
	StopLoop();
#ifdef DEBUG
	Serial << "FinalSuc - завершение функции" << NL;
#endif
}

//*********************************************************************
// Финал игры - неудача
//*********************************************************************
void FinalFail() {
int		i;					// Бегунок для циклов
boolean	bOn = true;				// Флаг включенного LEDа
#ifdef DEBUG
	Serial << "FinalFail - начало функции" << NL;
#endif
    digitalWrite(T3G, LOW);
    digitalWrite(T2G, LOW);
    digitalWrite(T1G, LOW);
		
	for (i=0; i<sEFailL; i++)
		{
		SoundPlay(sEFail[i][0], sEFail[i][1]);
    digitalWrite(T3R, bOn);
    digitalWrite(T2R, bOn);
    digitalWrite(T1R, bOn);
    bOn = !bOn;
		}
   StopLoop();
#ifdef DEBUG
	Serial << "FinalFail - завершение функции" << NL;
#endif
}

void StopLoop() {
int i;							//

#ifdef DEBUG
	Serial << "StopLoop - начало" << NL;
#endif

	noTone(ZUMM);					//
	delay(10000);					//
	digitalWrite(RELE, HIGH);			//
	for  (i = 0; i < LEDS_COUNT; i++) 		//
		{						//
		digitalWrite(LEDs[i], LOW);		//
		}						//
	MainClock.clearDisplay();			//
	Task3Clock.clearDisplay();			//
	CodeWindow.clearDisplay();			//
	noTone(ZUMM);					//
	bHalt = true;					// Установка флага остановки loop()
}
